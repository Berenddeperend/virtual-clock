<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>virtual-clock.js</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="A tiny library for configurable virtual clocks"/>
<meta name="author" content="DvdGiessen"/>
<meta name="keywords" content="virtual-clock clock timer stopwatch settimout setinterval virtual time timing timeout interval duration event hrtime hpet javascript npm nodejs browser es6 flow typescript"/>
<style type="text/css">
    body {
        max-width: 72ch;
        padding: 3ch;
        margin: auto;
        color: #333;
        font-size: 1.2em;
    }
    body {
        overflow-x: hidden;
    }
    code {
        white-space: pre-wrap;
    }
    code .comment {
        color: #999;
    }
    code.runkit + code.runkit {
        display: block;
        height: 0;
        overflow: hidden;
    }
    @media (prefers-color-scheme: dark) {
        :root, html {
            background-color: black;
        }
        :root > *, html > * {
            filter: invert(100%);
        }
        body {
            background-color: white;
        }
        * {
            background-color: inherit;
        }
        img, video, embed,  svg {
            background-color: black;
            filter: invert(100%);
        }
    }
</style>
</head>
<body>
<h1>virtual-clock</h1>
<p>
    <em>A tiny library for configurable virtual clocks</em>
</p>
<p>
    <a href="https://www.npmjs.com/package/virtual-clock"><img src="https://badgen.net/npm/v/virtual-clock" alt="npm"></a>
    <a href="https://github.com/DvdGiessen/virtual-clock/blob/master/LICENSE"><img src="https://badgen.net/github/license/dvdgiessen/virtual-clock" alt="license"></a>
    <a href="https://david-dm.org/DvdGiessen/virtual-clock"><img src="https://badgen.net/david/dep/dvdgiessen/virtual-clock" alt="dependencies" ></a>
    <a href="https://codecov.io/gh/DvdGiessen/virtual-clock"><img src="https://badgen.net/codecov/c/github/dvdgiessen/virtual-clock" alt="coverage"></a>
    <a href="https://www.codacy.com/app/github_94/virtual-clock"><img src="https://badgen.net/codacy/grade/bae573f4dab14b01af199ad21c810318" alt="code quality"></a>
    <a href="https://travis-ci.org/DvdGiessen/virtual-clock"><img src="https://travis-ci.org/DvdGiessen/virtual-clock.svg?branch=master" alt="build status"></a>
</p>
<h2>Overview</h2>
<p>
    <code>virtual-clock</code> is a tiny library for tracking time, for example in games,
    simulations, visualizations, media applications, or even just a stopwatch app.
</p>
<p>
    Virtual clocks can be paused and resumed, be sped up, down, or even made to go
    backwards, can be limited to not go beyond a certain minimum or maximum value,
    or to loop around whenever the set minimum or maximum value is reached.
</p>
<p>
    Clocks can register callbacks which should fire at specific clock times, either
    once or every time the clock reaches the specified time. Event listeners can
    also be attached for specific changes in state, for example to be notified when
    the clock is started or stopped.
</p>
<p>
    A VirtualClock's time is calculated using high resolution time data, meaning
    clock time is not affected by imprecision in JavaScript's timers, system clock
    drift or skewing by software like NTP. This makes it ideal for use in for
    example graphics render loops where the timing should not be bound to the speed
    at which the software runs.
</p>
<p>
    The library has extensive test coverage for all functionality and edge cases,
    provides type annotations for both TypeScript and Flow users, and is fully
    compatible with browsers, Node.js, and Deno environments.
</p>

<h2>Usage example</h2>
<code class="runkit" id="example-code">import VirtualClock from &apos;virtual-clock&apos;;
// or
const VirtualClock = require(&apos;virtual-clock&apos;);
// or
import VirtualClock from 'https://virtual-clock.js.org/1.2.3/virtual-clock.mjs';

// Create a new clock
let clock = new VirtualClock;

// At instanciation, the clock is stopped at time 0.
console.log(&apos;Initial clock time: &apos; + clock.time);

// The `time` property may be queried at any time, for example in a render loop
let outputElement = document.getElementById(&apos;output&apos;);
(function loop() {
    outputElement.textContent = (clock.time / 1000).toFixed(5);
    window.requestAnimationFrame(loop);
})();

// Start the clock by calling .start()
clock.start();

// Or toggling the `running` property
clock.running = true;

// Speed up the the flow of time
clock.rate = 2.0;

// Or wind back the clock
clock.rate = -1.0;

// By default, time is limited between -Infinity and Infinity
console.log(&apos;Default bounds: &apos; + clock.minimum + &apos; - &apos; + clock.maximum);

// But for various cases it might be useful to set a finite bound
clock.minimum = 0;
clock.maximum = 10 * 1000;

// When both minimum and maximum are set to non-infinites, we may loop time
clock.loop = true;

// Event listeners may be attached to notice changes
clock.on(&apos;start&apos;, () =&gt; {
    console.log(&apos;The clock has been started!&apos;);
});
clock.on(&apos;setrate&apos;, () =&gt; {
    console.log(&apos;The flow rate of time was set!&apos;);
});

// Time listeners can be attached to specific clock times
clock.onceAt(9 * 1000, () =&gt; {
    console.log(&apos;I\&apos;ll fire once at 9, and then never again!&apos;);
});
clock.alwaysAt(5 * 1000, () =&gt; {
    console.log(&apos;I\&apos;ll fire every time the clock is at 5!&apos;);
});

// We can keep adjusting properties; time listeners will fire as expected
clock.minimum += 1000;
clock.rate *= 2;
</code>
<h2>API</h2>
<code style="font-size: 0.75em;">class VirtualClock {
    <span class="comment">/**
     * Starts running the clock. Does nothing when clock was already running.
     */</span>
    start(): VirtualClock;

    <span class="comment">/**
     * Stops running the clock. Does nothing when clock was not running.
     */</span>
    stop(): VirtualClock;

    <span class="comment">/**
     * Attaches an event listener.
     *
     * Supported events:
     * start, stop, settime, setrunning, setrate, setminimum, setmaximum, setloop
     */</span>
    on(event: string, callback: () =&gt; mixed): VirtualClock;

    <span class="comment">/**
     * Detaches a previously attached event listener.
     */</span>
    off(event: string, callback: () =&gt; mixed): VirtualClock;

    <span class="comment">/**
     * Triggers an attached event listener.
     */</span>
    trigger(event: string, ...args: mixed[]): VirtualClock;

    <span class="comment">/**
     * Attaches a time listener which fires once after the specified clock time has passed.
     */</span>
    onceAt(time: number, callback: () =&gt; mixed): VirtualClock;

    <span class="comment">/**
     * Attaches a time listener which fires every time the specified clock time has passed.
     */</span>
    alwaysAt(time: number, callback: () =&gt; mixed): VirtualClock;

    <span class="comment">/**
     * Detaches a previously attached time listener.
     * If multiple listeners match, all are removed.
     */</span>
    removeAt(time: number, callback: () =&gt; mixed): VirtualClock;

    <span class="comment">/**
     * The current clock time.
     */</span>
    time: number;

    <span class="comment">/**
     * Whether the clock is currently running.
     */</span>
    running: boolean;

    <span class="comment">/**
     * The current rate (relative to real time) the clock runs at.
     */</span>
    rate: number;

    <span class="comment">/**
     * The minimum limit for time on the clock.
     */</span>
    minimum: number;

    <span class="comment">/**
     * The maximum limit for time on the clock.
     */</span>
    maximum: number;

    <span class="comment">/**
     * Whether the clock will loop around after reaching the maximum.
     */</span>
    loop: boolean;
}</code>
<p>
    Note that all methods return the called object to allow for method chaining.
</p>
<h2>Issues and contributing</h2>
<p>
    If you have any issues with <code>virtual-clock</code>, first check the
    <a href="https://github.com/DvdGiessen/virtual-clock/issues">issue tracker</a>
    to see whether it was already reported by someone else. If not, go ahead and
    <a href="https://github.com/DvdGiessen/virtual-clock/issues/new">create a new issue</a>.
    Try to include as much information (version of the library, example code to reproduce) as possible.
</p>
<p>
    If you want to contribute, feel free to open a pull request on
    <a href="https://github.com/DvdGiessen/virtual-clock">GitHub</a>!
</p>
<h2>License</h2>
<p>
    <code>virtual-clock</code> is freely distributable under the terms of the
    <a href="https://github.com/DvdGiessen/virtual-clock/blob/master/LICENSE">MIT license</a>.
</p>
<!-- The following scripts are all for the RunKit integration. -->
<script id="script-pako" src="https://unpkg.com/pako/dist/pako_deflate.es5.min.js" defer></script>
<script id="script-base64" type="module" src="https://unpkg.com/byte-base64/lib.es6.js"></script>
<script id="script-runkit" src="https://embed.runkit.com" defer></script>
<script type="module">
    // Progressive enhancement: All this code is only executed if the RunKit JavaScript actually loads
    if (window.RunKit) (async () => {
        // Create a clone of the example code which will be enhanced by RunKit
        const originalElement = document.getElementById('example-code');
        const clonedElement = originalElement.cloneNode(true);
        originalElement.removeAttribute('id');

        // Note: We use CSS classes instead of styles set by JS so both elements are affected at the same time,
        // ensuring everything should take only a single reflow operation.
        // Note: By placing the clone after the visible original, if the browser does render a frame with
        // an incomplete reflow, at least it'll be at the bottom of the page, hopefully below the fold.
        originalElement.parentNode.insertBefore(clonedElement, originalElement.nextSibling);

        // Replace the original element with the RunKit element when loading completes and add a fun little
        // typing effect to draw the users attention to the interactive part of the page.
        window.activateRunkitExampleCode = () => {
            const typeEffectTarget = originalElement.previousElementSibling.childNodes.item(0);
            const typeEffectText = 'Interactive ';
            const typeEffect = (offset, text) => {
                if (text.length > 0) {
                    typeEffectTarget.insertData(offset, text.substring(0, 1));
                    setTimeout(() => typeEffect(offset + 1, text.substring(1)), 100);
                } else {
                    typeEffectTarget.replaceData(
                        typeEffectText.length,
                        1,
                        typeEffectTarget.data.substring(
                            typeEffectText.length,
                            typeEffectText.length + 1
                        ).toLowerCase()
                    );
                }
            };
            typeEffect(0, typeEffectText);
            originalElement.parentNode.removeChild(originalElement);
        };

        // RunKit doesn't support the "import" syntax, so we comment it out
        const exampleCode = clonedElement.childNodes.item(0);
        const importOffset = exampleCode.data.indexOf('import');
        exampleCode.insertData(exampleCode.data.indexOf('import', importOffset + 1), '// ');
        exampleCode.insertData(importOffset, '// ');

        // The render loop should be adjusted for Node.js
        const codeRenderLoopOffset = exampleCode.data.indexOf('let outputElement')
        exampleCode.insertData(codeRenderLoopOffset, '// Note: Since this live example runs in Node.js this commented out.\n// There is a live view of the clock object in the console instead!\n/*');
        exampleCode.insertData(exampleCode.data.indexOf('();', codeRenderLoopOffset) + 3, '*/');
        const consoleOutputComment = 'This outputs the clock object to the console below';
        exampleCode.appendData('\n// ' + consoleOutputComment + '\nclock;\n\n// Try running this example code to see it in action!');

        // Check if pako is available. Without it, the preamble code we generate
        // is too big for RunKit and we may as well just skip it
        let preamble = '';
        if (window.pako) {
            // Add note on viewing the clock right within RunKit
            exampleCode.replaceData(
                exampleCode.data.indexOf(consoleOutputComment, codeRenderLoopOffset),
                consoleOutputComment.length,
                'In RunKit, clock objects can be seen live in the console below'
            );

            // Helper for extracting source of a function, which allows us to write
            // pure functions instead of escaping them in strings
            const getFunctionSource = func =>
                func
                .toString()
                .replace(/^(?:function(?:\s+[^\(\s]+)\s*\(\s*\)|\(\s*\)\s*=>)\s*\{([\S\s]+)\}$/g, '$1')
                .replace(/^\s+/mg, '')
                .replace(/\/\/ [^\n]+$/mg, '')
                .replace(/\s+/g, ' ');

            // Register a custom viewer of clocks for RunKit
            preamble = getFunctionSource(() => {
                // Operate in anonymous scope so we're not poluting the global namespace
                (() => {
                    // Load dependencies
                    const { ValueViewerSymbol } = require('@runkit/value-viewer');
                    const crypto = require('crypto');

                    // We only operate if virtual-clock is required
                    // To do so, we Proxy require() so we can enchance the VirtualClock object once it is loaded
                    require = new Proxy(require, {
                        apply: (target, thisArg, args) => {
                            let result = target.apply(thisArg, args);
                            if (args[0] === 'virtual-clock') {
                                result = new Proxy(result, {
                                    // We enhance the constructor of VirtualClock
                                    construct: (constructorTarget, constructorArgs) => {
                                        // Open a RunKit endpoint which will be used for updating clocks via Server-Sent Events
                                        if (!exports.endpoint) {
                                            exports.endpoint = (request, response) => {
                                                // Unique ID for this response object
                                                const responseId = crypto.randomBytes(32).toString('hex');

                                                // Set up headers for SSE
                                                response.writeHead(200, {
                                                    'Access-Control-Allow-Origin': '*',
                                                    'Content-Type': 'text/event-stream',
                                                    'Cache-Control': 'no-cache',
                                                    'Connection': 'keep-alive',
                                                });

                                                // For each clock, send the initial state
                                                for (const clockId in exports.endpoint.clocks) {
                                                    const clock = exports.endpoint.clocks[clockId];
                                                    // Deleted 'event:' + clockId + '\n'
                                                    // since RunKit appearantly starts a separate instance
                                                    // for handling endpoint request so ID's are not synced
                                                    response.write('data:' + JSON.stringify({
                                                        time: clock.time,
                                                        running: clock.running,
                                                        rate: clock.rate,
                                                        minimum: clock.minimum,
                                                        maximum: clock.maximum,
                                                        loop: clock.loop,
                                                    }) + '\n\n');
                                                }

                                                // Write 2KB of additional empty data, used for ensuring buffers are flushed
                                                response.write(':' + ' '.repeat(2048) + '\n');

                                                // Register the response so it may receive new events
                                                exports.endpoint.openConnections[responseId] = response;

                                                // Set up termination for this response after a timeout
                                                setTimeout(
                                                    () => {
                                                        delete exports.endpoint.openConnections[responseId];
                                                        response.end();
                                                    },
                                                    55 * 1000 // RunKit restriction: Requests must terminate within 60 seconds
                                                );
                                            };

                                            // List of clocks, used for transmitting initial state
                                            exports.endpoint.clocks = {};

                                            // List of open connection, used for sending events
                                            exports.endpoint.openConnections = {};

                                            // Function for sending event to all open connections
                                            exports.endpoint.sendEvent = (clockId, data) => {
                                                for (responseId in exports.endpoint.openConnections) {
                                                    const response = exports.endpoint.openConnections[responseId];
                                                    // Deleted 'event:' + clockId + '\n'
                                                    // since RunKit appearantly starts a separate instance
                                                    // for handling endpoint request so ID's are not synced
                                                    response.write('data:' + JSON.stringify(data) + '\n\n');
                                                    response.flushHeaders();
                                                }
                                            };
                                        }

                                        // Construct clock
                                        const clock = new constructorTarget(...constructorArgs);
                                        const clockId = crypto.randomBytes(8).toString('hex');
                                        exports.endpoint.clocks[clockId] = clock;

                                        // Send events on clock state changes
                                        for (const prop of ['time', 'running', 'rate', 'minimum', 'maximum', 'loop']) {
                                            clock.on('set' + prop, () => exports.endpoint.sendEvent(clockId, { [prop]: clock[prop] }));
                                        }

                                        // Add custom value viewer
                                        clock[ValueViewerSymbol] = {
                                            title: 'VirtualClock',
                                            HTML: ___clockRendererInit___
                                                .replace('%%%rawClockId%%%', clockId)
                                                .replace('__endPointUrl__', JSON.stringify(process.env.RUNKIT_ENDPOINT_URL))
                                                .replace('__clockId__', JSON.stringify(clockId)),
                                        };
                                        return clock;
                                    },
                                });
                            }
                            return result;
                        },
                    });
                })();
            }).replace(
                '___clockRendererInit___',
                JSON.stringify('<div id="virtualclock-%%%rawClockId%%%"></div><script>' + getFunctionSource(() => {
                    // If our renderer is not yet loaded, do so now
                    if (!window.virtualClockRenderer) {
                        // Set up temporary queueing function for until real renderer is available
                        window.virtualClockRenderer = clockId => window.virtualClockRenderer.queue.push(clockId);
                        window.virtualClockRenderer.queue = [];

                        // Await DOM ready before we insert the new script
                        document.addEventListener('DOMContentLoaded', () => {
                            // Add a new script to the page to load virtual-clock
                            const script = document.createElement('script');
                            script.async = true;
                            script.onload = () => {
                                // Store the queue of previously added clocks
                                const queue = window.virtualClockRenderer.queue;

                                // Start listening to events
                                const events = new EventSource(__endPointUrl__);

                                // Renderer function that sets up a clock
                                window.virtualClockRenderer = clockId => {
                                    // Instanciate the clock
                                    const clock = new VirtualClock();

                                    // Listen to events setting the clock state
                                    // Replaced clockId with 'message'
                                    // since RunKit appearantly starts a separate instance
                                    // for handling endpoint request so ID's are not synced
                                    events.addEventListener('message', event => {
                                        const eventData = JSON.parse(event.data);
                                        for(const prop in eventData) {
                                            clock[prop] = eventData[prop];
                                        }
                                    }, { passive: true });

                                    // Set up rendering of the clock state
                                    let outputElement = document.getElementById('virtualclock-' + clockId);
                                    (function loop() {
                                        outputElement.textContent =
                                            'Time: ' + (clock.time / 1000).toFixed(5) +
                                            ', running: ' + (clock.running ? 'true' : 'false') +
                                            ', rate: ' + clock.rate +
                                            ', minimum: ' + (clock.minimum / 1000).toFixed(5) +
                                            ', maximum: ' + (clock.maximum / 1000).toFixed(5) +
                                            ', loop: ' + (clock.loop ? 'true' : 'false');
                                        window.requestAnimationFrame(loop);
                                    })();
                                };

                                // Register all clocks that were previously queued
                                for (clockId of queue) {
                                    window.virtualClockRenderer(clockId);
                                }
                            };
                            script.src = 'https://unpkg.com/virtual-clock';
                            document.body.append(script);
                        }, false);
                    }

                    // Register the clock
                    window.virtualClockRenderer(__clockId__);
                }) + '</' + 'script>')
            );

            // Compress the preamble since RunKit breaks when its too big
            const { bytesToBase64 } = await import('https://unpkg.com/byte-base64/lib.es6.js');
            preamble = getFunctionSource(() => {
                eval(require('zlib').inflateSync(Buffer.from(__source__, 'base64')).toString('ascii'));
            }).replace('__source__', JSON.stringify(bytesToBase64(window.pako.deflate(preamble))));
        }

        // Build the Runkit workbook using all the things we've prepared
        window.RunKit.createNotebook({
            element: clonedElement,
            source: clonedElement.textContent,
            clearParentContents: true,
            preamble: preamble,
            onLoad: window.activateRunkitExampleCode,
            nodeVersion: '*',
        });

    })();
</script>
</body>
</html>
