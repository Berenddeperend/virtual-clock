{"version":3,"sources":["../src/virtual-clock.js"],"names":["VirtualClock","_now","performance","now","bind","process","hrtime","Date","_previousTime","_previousNow","_rate","_running","_minimum","Infinity","_maximum","_loop","_eventListeners","Map","_timeListeners","prop","startsWith","Object","defineProperty","enumerable","_recalculateTimeListeners","trigger","time","event","callback","listeners","get","push","set","i","indexOf","splice","Error","args","slice","forEach","listener","apply","keys","_recalculateTimeListener","listenerData","timeoutId","lastCalled","once","clearTimeout","currentTime","setTimeout","until","Math","abs","ceil","call","delete","NaN","isNaN","listenerTime","listenerCallback","min","max","running","start","stop","rate","minimum","previousTime","maximum","loop"],"mappings":"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","file":"virtual-clock.js","sourcesContent":["// @flow\n'use strict';\nexport default class VirtualClock {\n    _now: () => number;\n    _previousTime: number;\n    _previousNow: number;\n    _rate: number;\n    _running: boolean;\n    _minimum: number;\n    _maximum: number;\n    _loop: boolean;\n    _eventListeners: Map<string, (() => mixed)[]>;\n    _timeListeners: Map<[number, () => mixed], [number, number, boolean]>;\n\n    /**\n     * Constructs a stopped clock with default settings.\n     */\n    constructor(): void {\n        // Determine method for retrieving now\n        this._now =\n            (typeof performance !== 'undefined' && /*global performance */ performance.now.bind(performance)) ||\n            (typeof process !== 'undefined' && /*global process */ process.hrtime && ((): number => {\n                let now: [number, number] = process.hrtime();\n                return now[0] * 1e3 + now[1] / 1e6;\n            })) ||\n            Date.now\n        ;\n\n        // Current state\n        this._previousTime = 0;\n        this._previousNow = this._now();\n\n        // Flow of time configuration\n        this._rate = 1.0;\n        this._running = false;\n\n        // Minimum / maximum / looping configuration\n        this._minimum = -Infinity;\n        this._maximum = Infinity;\n        this._loop = false;\n\n        // Event and time listeners\n        this._eventListeners = new Map();\n        this._timeListeners = new Map();\n\n        // Make private properties non-enumerable\n        for(let prop in this) {\n            if(prop.startsWith('_')) {\n                Object.defineProperty(this, prop, { enumerable: false });\n            }\n        }\n    }\n\n    // Methods\n    /**\n     * Starts running the clock. Does nothing when clock was already running.\n     */\n    start(): VirtualClock {\n        // Start running the time if we werent running\n        if(!this._running) {\n            this._previousNow = this._now();\n            this._running = true;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('start');\n            this.trigger('setrunning');\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Stops running the clock. Does nothing when clock was not running.\n     */\n    stop(): VirtualClock {\n        // Stops running the time if we were running\n        if(this._running) {\n            this._previousTime = this.time;\n            this._running = false;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('stop');\n            this.trigger('setrunning');\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Attaches an event listener.\n     *\n     * Supported events: start, stop, settime, setrunning, setrate, setminimum, setmaximum, setloop\n     */\n    on(event: string, callback: () => mixed): VirtualClock {\n        // Add the listener\n        let listeners = this._eventListeners.get(event);\n        if(listeners) {\n            listeners.push(callback);\n        } else {\n            this._eventListeners.set(event, [callback]);\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Detaches a previously attached event listener.\n     */\n    off(event: string, callback: () => mixed): VirtualClock {\n        // Find the listener\n        let listeners = this._eventListeners.get(event);\n        if(listeners) {\n            let i = listeners.indexOf(callback);\n            if(i >= 0) {\n                // Remove the listener\n                listeners.splice(i, 1);\n\n                // Method chaining\n                return this;\n            }\n        }\n\n        // When not found, throw an error\n        throw new Error('Event listener not found');\n    }\n\n    /**\n     * Triggers an attached event listener.\n     */\n    trigger(event: string, ...args: mixed[]): VirtualClock {\n        let listeners = this._eventListeners.get(event);\n        if(listeners) {\n            listeners.slice(0).forEach((listener) => {\n                listener.apply(this, args);\n            });\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Private method for recalculating all registered time listeners.\n     */\n    _recalculateTimeListeners(): void {\n        for(let listener of this._timeListeners.keys()) {\n            this._recalculateTimeListener(listener);\n        }\n    }\n\n    /**\n     * Private method for recalculating a specific registered time listener.\n     */\n    _recalculateTimeListener(listener: [number, () => mixed]): void {\n        // Check if the listener is still registered\n        let listenerData = this._timeListeners.get(listener);\n        if(listenerData) {\n            let [time, callback] = listener;\n            let [timeoutId, lastCalled, once] = listenerData;\n\n            // Clear any open timeouts\n            clearTimeout(timeoutId);\n\n            // Only add timeouts if we're running and the time is reachable\n            if(this._running && this._rate !== 0 && time >= this._minimum && time <= this._maximum) {\n                // Get current time\n                let currentTime = this.time;\n\n                // Did we already run at this time?\n                if(currentTime === lastCalled) {\n                    // Is is possible to wait?\n                    if(this._loop || currentTime !== this._minimum && currentTime !== this._maximum) {\n                        // Wait until the time has changed enough to prevent racing and then retry\n                        this._timeListeners.set(listener, [setTimeout(() => {\n                            this._recalculateTimeListener(listener);\n                        }, 1), lastCalled, once]);\n                    }\n                } else {\n                    // Clock time until the listener should be triggered\n                    let until;\n\n                    // Initial calculation depends on which way time is moving\n                    if(this._rate > 0) {\n                        until = time - currentTime;\n                    } else {\n                        until = currentTime - time;\n                    }\n\n                    // If the time is going to be reached\n                    if(until >= 0 || this._loop && this._minimum > -Infinity && this._maximum < Infinity) {\n                        // Add time when looping\n                        if(until < 0) {\n                            until += (this._maximum - this._minimum);\n                        }\n\n                        // Factor in the rate\n                        until *= 1 / Math.abs(this._rate);\n\n                        // Ceil the value, otherwise setTimeout may floor it and run before it is supposed to\n                        until = Math.ceil(until);\n\n                        // Set timeout\n                        this._timeListeners.set(listener, [setTimeout(() => {\n                            // Safety checkif listener is still registered\n                            let listenerData = this._timeListeners.get(listener);\n                            if(listenerData) {\n                                // Re-acquire once\n                                let [, , once] = listenerData;\n\n                                // Save time of call\n                                this._timeListeners.set(listener, [0, this.time, once]);\n\n                                // Call the callback\n                                callback.call(this);\n\n                                // Should we self-destruct\n                                if(once) {\n                                    this._timeListeners.delete(listener);\n                                } else {\n                                    // Recalculate the time listener\n                                    this._recalculateTimeListener(listener);\n                                }\n                            }\n                        }, until), NaN, once]);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Attaches a time listener which fires once after the specified clock time has passed.\n     */\n    onceAt(time: number, callback: () => mixed): VirtualClock {\n        // Do not allow setting an invalid value\n        if(isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Can only set time to a finite number');\n        }\n\n        let listener = [time, callback];\n        this._timeListeners.set(listener, [0, NaN, true]);\n        this._recalculateTimeListener(listener);\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Attaches a time listener which fires every time the specified clock time has passed.\n     */\n    alwaysAt(time: number, callback: () => mixed): VirtualClock {\n        // Do not allow setting an invalid value\n        if(isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Can only set time to a finite number');\n        }\n\n        let listener = [time, callback];\n        this._timeListeners.set(listener, [0, NaN, false]);\n        this._recalculateTimeListener(listener);\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Detaches a previously attached time listener.\n     */\n    removeAt(time: number, callback: () => mixed): VirtualClock {\n        // Loop over all listeners\n        for(let listener of this._timeListeners.keys()) {\n            let [listenerTime, listenerCallback] = listener;\n\n            // If the listener matches, delete it\n            if(listenerTime === time && listenerCallback === callback) {\n                this._timeListeners.delete(listener);\n            }\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    // Getters\n    /**\n     * The current clock time.\n     */\n    get time(): number {\n        let currentTime = this._previousTime;\n\n        // If running, the time is has changed since the previous time so we recalculate it\n        if(this._running) {\n            // Calculate current time based on passed time\n            currentTime += this._rate * (this._now() - this._previousNow);\n        }\n\n        // Can we loop (loop enabled + a non-zero non-finite maximum)\n        if(this._loop && this._minimum > -Infinity && this._maximum < Infinity) {\n            // Calculate using modulo, adjusting for the minimum\n            currentTime = ((currentTime - this._minimum) % (this._maximum - this._minimum) + (this._maximum - this._minimum)) % (this._maximum - this._minimum) + this._minimum;\n        } else {\n            // No looping means we just limit our output between minimum and maximum\n            currentTime = Math.min(Math.max(this._minimum, currentTime), this._maximum);\n        }\n\n        return currentTime;\n    }\n\n    /**\n     * Whether the clock is currently running.\n     */\n    get running(): boolean {\n        return this._running;\n    }\n\n    /**\n     * The current rate (relative to real time) the clock runs at.\n     */\n    get rate(): number {\n        return this._rate;\n    }\n\n    /**\n     * The minimum limit for time on the clock.\n     */\n    get minimum(): number {\n        return this._minimum;\n    }\n\n    /**\n     * The maximum limit for time on the clock.\n     */\n    get maximum(): number {\n        return this._maximum;\n    }\n\n    /**\n     * Whether the clock will loop around after reaching the maximum.\n     */\n    get loop(): boolean {\n        return this._loop;\n    }\n\n    // Setters\n    /**\n     * Sets the current clock time.\n     */\n    set time(time: number): void {\n        // Do not allow setting an invalid value\n        if(isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Can only set time to a finite number');\n        }\n\n        // Only act if the time is different\n        // Note: If time is changing, it is always assumed to be different\n        let currentTime = this.time;\n        if(\n            !(\n                !this._running ||\n                this._rate === 0.0 ||\n                !this._loop && (\n                    this._rate < 0 && currentTime === this._minimum ||\n                    this._rate > 0 && currentTime === this._maximum\n                )\n            ) || (time !== currentTime)\n        ) {\n            // Recalibrate by setting both correct time and now\n            this._previousTime = Math.min(Math.max(this._minimum, time), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('settime');\n        }\n    }\n\n    /**\n     * Starts or stops running the clock.\n     */\n    set running(running: boolean): void {\n        // Changing running state just calls start() or stop()\n        running ? this.start() : this.stop();\n    }\n\n    /**\n     * Sets the rate (relative to real time) at which the clock runs.\n     */\n    set rate(rate: number): void {\n        // Do not allow setting an invalid value\n        if(isNaN(rate) || rate === -Infinity || rate === Infinity) {\n            throw new Error('Can only set rate to a finite number');\n        }\n\n        // Only act if the rate is different\n        if(rate !== this._rate) {\n            // Recalibration is only needed when we're running\n            if(this._running) {\n                this._previousTime = this.time;\n                this._previousNow = this._now();\n            }\n\n            // Set rate\n            this._rate = rate;\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setrate');\n        }\n    }\n\n    /**\n     * Sets minimum limit for time on the clock.\n     */\n    set minimum(minimum: number): void {\n        // Do not allow setting an invalid value\n        if(minimum > this._maximum || isNaN(minimum) || minimum === Infinity) {\n            throw new Error('Cannot set minimum above maximum');\n        }\n\n        // Only act if the minimum is different\n        if(minimum !== this._minimum) {\n            // First get the calculated time, calculated using the old minimum\n            let previousTime = this.time;\n\n            // Change the minimum\n            this._minimum = minimum;\n\n            // Recalibrate the time using the previous value and the new minimum\n            this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setminimum');\n        }\n    }\n\n    /**\n     * Sets maximum limit for time on the clock.\n     */\n    set maximum(maximum: number): void {\n        // Do not allow setting an invalid value\n        if(maximum < this._minimum || isNaN(maximum) || maximum === -Infinity) {\n            throw new Error('Cannot set maximum below minimum');\n        }\n\n        // Only act if the maximum is different\n        if(maximum !== this._maximum) {\n            // First get the calculated time, calculated using the old maximum\n            let previousTime = this.time;\n\n            // Change the maximum\n            this._maximum = maximum;\n\n            // Recalibrate the time using the previous value and the new maximum\n            this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setmaximum');\n        }\n    }\n\n    /**\n     * Sets whether the clock loops around after reaching the maximum.\n     */\n    set loop(loop: boolean): void {\n        // Only act if looping is different\n        if(loop !== this._loop) {\n            // Recalibrate\n            this._previousTime = this.time;\n            this._previousNow = this._now();\n\n            // Set looping\n            this._loop = loop;\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setloop');\n        }\n    }\n}\n"]}