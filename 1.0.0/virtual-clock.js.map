{"version":3,"sources":["../src/virtual-clock.js"],"names":["VirtualClock","_now","performance","now","process","hrtime","Date","getTime","_previousTime","_previousNow","_rate","_running","_minimum","Infinity","_maximum","_loop","_eventListeners","Map","_timeListeners","prop","startsWith","Object","defineProperty","enumerable","_recalculateTimeListeners","trigger","time","event","callback","listeners","get","push","set","i","indexOf","splice","Error","args","slice","forEach","listener","apply","keys","_recalculateTimeListener","listenerData","timeoutId","lastCalled","once","clearTimeout","currentTime","setTimeout","until","Math","abs","ceil","call","delete","NaN","listenerTime","listenerCallback","min","max","running","start","stop","rate","minimum","previousTime","maximum","loop"],"mappings":"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","file":"virtual-clock.js","sourcesContent":["// @flow\n'use strict';\nexport default class VirtualClock {\n    _now: Function;\n    _previousTime: number;\n    _previousNow: number;\n    _rate: number;\n    _running: boolean;\n    _minimum: number;\n    _maximum: number;\n    _loop: boolean;\n    _eventListeners: Map<string, Function[]>;\n    _timeListeners: Map<[number, Function], [number, number, boolean]>;\n    \n    /**\n     * Constructs a stopped clock with default settings.\n     */\n    constructor() {\n        // Determine method for retrieving now\n        this._now =\n            (typeof performance !== 'undefined' && /*global performance */ performance.now) ||\n            (typeof process !== 'undefined' && /*global process */ process.hrtime && (() => { let now = process.hrtime(); return now[0] * 1e3 + now[1] / 1e6; })) ||\n            Date.now ||\n            (() => { return new Date().getTime(); });\n        \n        // Current state\n        this._previousTime = 0;\n        this._previousNow = this._now();\n\n        // Flow of time configuration\n        this._rate = 1.0;\n        this._running = false;\n\n        // Minimum / maximum / looping configuration\n        this._minimum = -Infinity;\n        this._maximum = Infinity;\n        this._loop = false;\n\n        // Event and time listeners\n        this._eventListeners = new Map();\n        this._timeListeners = new Map();\n        \n        // Make private properties non-enumerable\n        for(let prop in this) {\n            if(prop.startsWith('_')) {\n                Object.defineProperty(this, prop, { enumerable: false });\n            }\n        }\n    }\n\n    // Methods\n    /**\n     * Starts running the clock. Does nothing when clock was already running.\n     */\n    start(): VirtualClock {\n        // Start running the time if we werent running\n        if(!this._running) {\n            this._previousNow = this._now();\n            this._running = true;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('start');\n        }\n\n        // Trigger setrunning listeners\n        this.trigger('setrunning');\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Stops running the clock. Does nothing when clock was not running.\n     */\n    stop(): VirtualClock {\n        // Stops running the time if we were running\n        if(this._running) {\n            this._previousTime = this.time;\n            this._running = false;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('stop');\n        }\n\n        // Trigger setrunning listeners\n        this.trigger('setrunning');\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Attaches an event listener.\n     *\n     * Supported events: start, stop, settime, setrunning, setrate, setminimum, setmaximum, setloop\n     */\n    on(event: string, callback: Function): VirtualClock {\n        // Add the listener\n        let listeners = this._eventListeners.get(event);\n        if(listeners) {\n            listeners.push(callback);\n        } else {\n            this._eventListeners.set(event, [callback]);\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Detaches a previously attached event listener.\n     */\n    off(event: string, callback: Function): VirtualClock {\n        // Find the listener\n        let listeners = this._eventListeners.get(event);\n        if(listeners) {\n            let i = listeners.indexOf(callback);\n            if(i >= 0) {\n                // Remove the listener\n                listeners.splice(i, 1);\n\n                // Method chaining\n                return this;\n            }\n        }\n\n        // When not found, throw an error\n        throw new Error('Event listener not found');\n    }\n\n    /**\n     * Triggers an attached event listener.\n     */\n    trigger(event: string, ...args: mixed[]): VirtualClock {\n        let listeners = this._eventListeners.get(event);\n        if(listeners) {\n            listeners.slice(0).forEach((listener) => {\n                listener.apply(this, args);\n            });\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Private method for recalculating all registered time listeners.\n     */\n    _recalculateTimeListeners() {\n        for(let listener of this._timeListeners.keys()) {\n            this._recalculateTimeListener(listener);\n        }\n    }\n\n    /**\n     * Private method for recalculating a specific registered time listener.\n     */\n    _recalculateTimeListener(listener: [number, Function]) {\n        // Check if the listener is still registered\n        let listenerData = this._timeListeners.get(listener);\n        if(listenerData) {\n            let [time, callback] = listener;\n            let [timeoutId, lastCalled, once] = listenerData;\n\n            // Clear any open timeouts\n            clearTimeout(timeoutId);\n\n            // Only add timeouts if we're running and the time is reachable\n            if(this._running && this._rate != 0 && time >= this._minimum && time <= this._maximum) {\n                // Get current time\n                let currentTime = this.time;\n\n                // Did we already run at this time?\n                if(currentTime === lastCalled) {\n                    // Is is possible to wait?\n                    if(this._loop || currentTime !== this._minimum && currentTime !== this._maximum) {\n                        // Wait until the time has changed enough to prevent racing and then retry\n                        this._timeListeners.set(listener, [setTimeout(() => {\n                            this._recalculateTimeListener(listener);\n                        }, 1), lastCalled, once]);\n                    }\n                } else {\n                    // Clock time until the listener should be triggered\n                    let until;\n\n                    // Initial calculation depends on which way time is moving\n                    if(this._rate > 0) {\n                        until = time - currentTime;\n                    } else {\n                        until = currentTime - time;\n                    }\n\n                    // If the time is going to be reached\n                    if(until >= 0 || this._loop && this._minimum > -Infinity && this._maximum < Infinity) {\n                        // Add time when looping\n                        if(until < 0) {\n                            until += (this._maximum - this._minimum);\n                        }\n\n                        // Factor in the rate\n                        until *= 1 / Math.abs(this._rate);\n\n                        // Ceil the value, otherwise setTimeout may floor it and run before it is supposed to\n                        until = Math.ceil(until);\n\n                        // Set timeout\n                        this._timeListeners.set(listener, [setTimeout(() => {\n                            // Safety checkif listener is still registered\n                            let listenerData = this._timeListeners.get(listener);\n                            if(listenerData) {\n                                // Re-acquire once\n                                let [, , once] = listenerData;\n\n                                // Save time of call\n                                this._timeListeners.set(listener, [0, this.time, once]);\n\n                                // Call the callback\n                                callback.call(this);\n\n                                // Should we self-destruct\n                                if(once) {\n                                    this._timeListeners.delete(listener);\n                                } else {\n                                    // Recalculate the time listener\n                                    this._recalculateTimeListener(listener);\n                                }\n                            }\n                        }, until), NaN, once]);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Attaches a time listener which fires once after the specified clock time has passed.\n     */\n    onceAt(time: number, callback: Function): VirtualClock {\n        let listener = [time, callback];\n        this._timeListeners.set(listener, [0, NaN, true]);\n        this._recalculateTimeListener(listener);\n        \n        // Method chaining\n        return this;\n    }\n    \n    /**\n     * Attaches a time listener which fires every time the specified clock time has passed.\n     */\n    alwaysAt(time: number, callback: Function): VirtualClock {\n        let listener = [time, callback];\n        this._timeListeners.set(listener, [0, NaN, false]);\n        this._recalculateTimeListener(listener);\n        \n        // Method chaining\n        return this;\n    }\n    \n    /**\n     * Detaches a previously attached time listener.\n     */\n    removeAt(time: number, callback: Function): VirtualClock {\n        // Loop over all listeners\n        for(let listener of this._timeListeners.keys()) {\n            let [listenerTime, listenerCallback] = listener;\n            \n            // If the listener matches, delete it\n            if(listenerTime === time && listenerCallback === callback) {\n                this._timeListeners.delete(listener);\n            }\n        }\n        \n        // Method chaining\n        return this;\n    }\n\n    // Getters\n    /**\n     * The current clock time.\n     */\n    get time(): number {\n        let currentTime = this._previousTime;\n\n        // If running, the time is has changed since the previous time so we recalculate it\n        if(this._running) {\n            // Calculate current time based on passed time\n            currentTime += this._rate * (this._now() - this._previousNow);\n        }\n\n        // Can we loop (loop enabled + a non-zero non-finite maximum)\n        if(this._loop && this._minimum > -Infinity && this._maximum < Infinity) {\n            // Is the time below the minimum (meaning we are looping backwards)\n            if(currentTime < this._minimum) {\n                // Append until we're between bounds again\n                do {\n                    currentTime += (this._maximum - this._minimum);\n                } while(currentTime < this._minimum);\n            } else {\n                // Performance: If the minimum is zero, just calculate our current position in the loop by modulo\n                if(this._minimum == 0) {\n                    currentTime %= this._maximum;\n                } else {\n                    // Substract until we're between bounds again\n                    while(currentTime >= this._maximum) {\n                        currentTime -= (this._maximum - this._minimum);\n                    }\n                }\n            }\n        } else {\n            // No looping means we just limit our output between minimum and maximum\n            currentTime = Math.min(Math.max(this._minimum, currentTime), this._maximum);\n        }\n\n        return currentTime;\n    }\n\n    /**\n     * Whether the clock is currently running.\n     */\n    get running(): boolean {\n        return this._running;\n    }\n\n    /**\n     * The current rate (relative to real time) the clock runs at.\n     */\n    get rate(): number {\n        return this._rate;\n    }\n\n    /**\n     * The minimum limit for time on the clock.\n     */\n    get minimum(): number {\n        return this._minimum;\n    }\n\n    /**\n     * The maximum limit for time on the clock.\n     */\n    get maximum(): number {\n        return this._maximum;\n    }\n\n    /**\n     * Whether the clock will loop around after reaching the maximum.\n     */\n    get loop(): boolean {\n        return this._loop;\n    }\n\n    // Setters\n    /**\n     * Sets the current clock time.\n     */\n    set time(time: number) {\n        // Recalibrate by setting both correct time and now\n        this._previousTime = Math.min(Math.max(this._minimum, time), this._maximum);\n        this._previousNow = this._now();\n\n        // Recalculate time listeners\n        this._recalculateTimeListeners();\n\n        // Trigger event listeners\n        this.trigger('settime');\n    }\n    \n    /**\n     * Starts or stops running the clock.\n     */\n    set running(running: boolean) {\n        // Changing running state just calls start() or stop()\n        running ? this.start() : this.stop();\n    }\n    \n    /**\n     * Sets the rate (relative to real time) at which the clock runs.\n     */\n    set rate(rate: number) {\n        // Recalibration is only needed when we're running\n        if(this._running) {\n            this._previousTime = this.time;\n            this._previousNow = this._now();\n        }\n\n        // Set rate\n        this._rate = rate;\n\n        // Recalculate time listeners\n        this._recalculateTimeListeners();\n\n        // Trigger event listeners\n        this.trigger('setrate');\n    }\n    \n    /**\n     * Sets minimum limit for time on the clock.\n     */\n    set minimum(minimum: number) {\n        // First get the calculated time, calculated using the old minimum\n        let previousTime = this.time;\n        \n        // Do not allow setting a minimum above the maximum\n        if(minimum > this._maximum || minimum == Infinity) {\n            throw new Error('Cannot set minimum above maximum');\n        }\n\n        // Change the minimum\n        this._minimum = minimum;\n\n        // Recalibrate the time using the previous value and the new minimum\n        this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n        this._previousNow = this._now();\n\n        // Recalculate time listeners\n        this._recalculateTimeListeners();\n\n        // Trigger event listeners\n        this.trigger('setminimum');\n    }\n    \n    /**\n     * Sets maximum limit for time on the clock.\n     */\n    set maximum(maximum: number) {\n        // First get the calculated time, calculated using the old maximum\n        let previousTime = this.time;\n        \n        // Do not allow setting a maximum below the minimum\n        if(maximum < this._minimum || maximum == -Infinity) {\n            throw new Error('Cannot set maximum below minimum');\n        }\n\n        // Change the maximum\n        this._maximum = maximum;\n\n        // Recalibrate the time using the previous value and the new maximum\n        this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n        this._previousNow = this._now();\n\n        // Recalculate time listeners\n        this._recalculateTimeListeners();\n\n        // Trigger event listeners\n        this.trigger('setmaximum');\n    }\n\n    /**\n     * Sets whether the clock loops around after reaching the maximum.\n     */\n    set loop(loop: boolean) {\n        // Recalibrate\n        this._previousTime = this.time;\n        this._previousNow = this._now();\n\n        // Set looping\n        this._loop = loop;\n\n        // Recalculate time listeners\n        this._recalculateTimeListeners();\n\n        // Trigger event listeners\n        this.trigger('setloop');\n    }\n}\n"]}