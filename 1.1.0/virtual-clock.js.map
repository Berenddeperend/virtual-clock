{"version":3,"sources":["../src/virtual-clock.js"],"names":["VirtualClock","_now","performance","now","bind","process","hrtime","Date","_previousTime","_previousNow","_rate","_running","_minimum","Infinity","_maximum","_loop","_eventListeners","Map","_timeListeners","_nullTimeoutID","setTimeout","prop","startsWith","Object","defineProperty","enumerable","_recalculateTimeListeners","trigger","time","event","callback","listeners","get","push","set","i","indexOf","splice","Error","args","slice","forEach","listener","apply","keys","_recalculateTimeListener","listenerData","timeoutID","lastCalled","once","clearTimeout","currentTime","until","Math","abs","ceil","delete","call","NaN","isNaN","hasRemoved","listenerTime","listenerCallback","min","max","running","start","stop","rate","minimum","previousTime","maximum","loop"],"mappings":"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","file":"virtual-clock.js","sourcesContent":["// @flow\n'use strict';\n\n/**\n * A configurable virtual clock for tracking time.\n *\n * @author DaniÃ«l van de Giessen\n * @see https://github.com/DvdGiessen/virtual-clock#readme\n */\nexport default class VirtualClock {\n    _now: () => number;\n    _previousTime: number;\n    _previousNow: number;\n    _rate: number;\n    _running: boolean;\n    _minimum: number;\n    _maximum: number;\n    _loop: boolean;\n    _eventListeners: Map<string, (() => mixed)[]>;\n    _timeListeners: Map<[number, () => mixed], [TimeoutID, number, boolean]>;\n    _nullTimeoutID: TimeoutID;\n\n    /**\n     * Constructs a stopped clock with default settings.\n     */\n    constructor(): void {\n        // Determine method for retrieving now\n        this._now =\n            (typeof performance !== 'undefined' && /*global performance */ performance.now.bind(performance)) ||\n            (typeof process !== 'undefined' && /*global process */ process.hrtime && ((): number => {\n                const now: [number, number] = process.hrtime();\n                return now[0] * 1e3 + now[1] / 1e6;\n            })) ||\n            Date.now;\n\n        // Current state\n        this._previousTime = 0;\n        this._previousNow = this._now();\n\n        // Flow of time configuration\n        this._rate = 1.0;\n        this._running = false;\n\n        // Minimum / maximum / looping configuration\n        this._minimum = -Infinity;\n        this._maximum = Infinity;\n        this._loop = false;\n\n        // Event and time listeners\n        this._eventListeners = new Map();\n        this._timeListeners = new Map();\n\n        // Create unique TimeoutID to track non-scheduled timers\n        this._nullTimeoutID = setTimeout(() => {}, 0);\n\n        // Make private properties non-enumerable\n        for (const prop in this) {\n            if (prop.startsWith('_')) {\n                Object.defineProperty(this, prop, { enumerable: false });\n            }\n        }\n    }\n\n    // Methods\n    /**\n     * Starts running the clock. Does nothing when clock was already running.\n     */\n    start(): VirtualClock {\n        // Start running the time if we werent running\n        if (!this._running) {\n            this._previousNow = this._now();\n            this._running = true;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('start');\n            this.trigger('setrunning');\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Stops running the clock. Does nothing when clock was not running.\n     */\n    stop(): VirtualClock {\n        // Stops running the time if we were running\n        if (this._running) {\n            this._previousTime = this.time;\n            this._running = false;\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('stop');\n            this.trigger('setrunning');\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Attaches an event listener.\n     *\n     * Supported events: start, stop, settime, setrunning, setrate, setminimum, setmaximum, setloop\n     */\n    on(event: string, callback: () => mixed): VirtualClock {\n        // Add the listener\n        const listeners = this._eventListeners.get(event);\n        if (listeners) {\n            listeners.push(callback);\n        } else {\n            this._eventListeners.set(event, [callback]);\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Detaches a previously attached event listener.\n     */\n    off(event: string, callback: () => mixed): VirtualClock {\n        // Find the listener\n        const listeners = this._eventListeners.get(event);\n        if (listeners) {\n            const i = listeners.indexOf(callback);\n            if (i >= 0) {\n                // Remove the listener\n                listeners.splice(i, 1);\n\n                // Method chaining\n                return this;\n            }\n        }\n\n        // When not found, throw an error\n        throw new Error('Event listener not found');\n    }\n\n    /**\n     * Triggers an attached event listener.\n     */\n    trigger(event: string, ...args: mixed[]): VirtualClock {\n        const listeners = this._eventListeners.get(event);\n        if (listeners) {\n            listeners.slice(0).forEach(listener => {\n                listener.apply(this, args);\n            });\n        }\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Private method for recalculating all registered time listeners.\n     */\n    _recalculateTimeListeners(): void {\n        for (const listener of this._timeListeners.keys()) {\n            this._recalculateTimeListener(listener);\n        }\n    }\n\n    /**\n     * Private method for recalculating a specific registered time listener.\n     */\n    _recalculateTimeListener(listener: [number, () => mixed]): void {\n        // Check if the listener is still registered\n        const listenerData = this._timeListeners.get(listener);\n        if (listenerData) {\n            const [time, callback] = listener;\n            const [timeoutID, lastCalled, once] = listenerData;\n\n            // Clear any open timeouts\n            clearTimeout(timeoutID);\n\n            // Only add timeouts if we're running and the time is reachable\n            if (this._running && this._rate !== 0 && time >= this._minimum && time <= this._maximum) {\n                // Get current time\n                const currentTime = this.time;\n\n                // Did we already run at this time?\n                if (currentTime === lastCalled) {\n                    // Is is possible to wait?\n                    if (this._loop || (currentTime !== this._minimum && currentTime !== this._maximum)) {\n                        // Wait until the time has changed enough to prevent racing and then retry\n                        this._timeListeners.set(listener, [setTimeout(() => {\n                            this._recalculateTimeListener(listener);\n                        }, 1), lastCalled, once]);\n                    }\n                } else {\n                    // Clock time until the listener should be triggered\n                    let until;\n\n                    // Initial calculation depends on which way time is moving\n                    if (this._rate > 0) {\n                        until = time - currentTime;\n                    } else {\n                        until = currentTime - time;\n                    }\n\n                    // If the time is going to be reached\n                    if (until >= 0 || (this._loop && this._minimum > -Infinity && this._maximum < Infinity)) {\n                        // Add time when looping\n                        if (until < 0) {\n                            until += this._maximum - this._minimum;\n                        }\n\n                        // Factor in the rate\n                        until *= 1 / Math.abs(this._rate);\n\n                        // Ceil the value, otherwise setTimeout may floor it and run before it is supposed to\n                        until = Math.ceil(until);\n\n                        // Set timeout\n                        this._timeListeners.set(listener, [setTimeout(() => {\n                            // Should we self-destruct\n                            if (once) {\n                                this._timeListeners.delete(listener);\n                            } else {\n                                // Save time of call\n                                this._timeListeners.set(listener, [this._nullTimeoutID, this.time, once]);\n                            }\n\n                            // Call the callback\n                            callback.call(this);\n\n                            // Recalculate the time listener\n                            if (!once) {\n                                this._recalculateTimeListener(listener);\n                            }\n                        }, until), NaN, once]);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Attaches a time listener which fires once after the specified clock time has passed.\n     */\n    onceAt(time: number, callback: () => mixed): VirtualClock {\n        // Do not allow setting an invalid value\n        if (isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Can only set time to a finite number');\n        }\n\n        const listener = [time, callback];\n        this._timeListeners.set(listener, [this._nullTimeoutID, NaN, true]);\n        this._recalculateTimeListener(listener);\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Attaches a time listener which fires every time the specified clock time has passed.\n     */\n    alwaysAt(time: number, callback: () => mixed): VirtualClock {\n        // Do not allow setting an invalid value\n        if (isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Can only set time to a finite number');\n        }\n\n        const listener = [time, callback];\n        this._timeListeners.set(listener, [this._nullTimeoutID, NaN, false]);\n        this._recalculateTimeListener(listener);\n\n        // Method chaining\n        return this;\n    }\n\n    /**\n     * Detaches a previously attached time listener. If multiple listeners match, all are removed.\n     */\n    removeAt(time: number, callback: () => mixed): VirtualClock {\n        // Track whether we removed anything\n        let hasRemoved = false;\n\n        // Loop over all listeners\n        for (const listener of this._timeListeners.keys()) {\n            const [listenerTime, listenerCallback] = listener;\n            if (listenerTime === time && listenerCallback === callback) {\n                // Cancel the timeout\n                const listenerData = this._timeListeners.get(listener);\n                if (listenerData) {\n                    clearTimeout(listenerData[0]);\n                }\n\n                // Remove the listener\n                this._timeListeners.delete(listener);\n\n                // We have removed at least one listener\n                hasRemoved = true;\n            }\n        }\n\n        if (hasRemoved) {\n            // Method chaining\n            return this;\n        } else {\n            // When not found, throw an error\n            throw new Error('Time listener not found');\n        }\n    }\n\n    // Getters\n    /**\n     * The current clock time.\n     */\n    get time(): number {\n        let currentTime = this._previousTime;\n\n        // If running, the time is has changed since the previous time so we recalculate it\n        if (this._running) {\n            // Calculate current time based on passed time\n            currentTime += this._rate * (this._now() - this._previousNow);\n        }\n\n        // Can we loop (loop enabled + a non-zero non-finite maximum)\n        if (this._loop && (this._minimum > -Infinity && this._maximum < Infinity)) {\n            // Calculate using modulo, adjusting for the minimum\n            currentTime = ((currentTime - this._minimum) % (this._maximum - this._minimum) + (this._maximum - this._minimum)) % (this._maximum - this._minimum) + this._minimum;\n        } else {\n            // No looping means we just limit our output between minimum and maximum\n            currentTime = Math.min(Math.max(this._minimum, currentTime), this._maximum);\n        }\n\n        return currentTime;\n    }\n\n    /**\n     * Whether the clock is currently running.\n     */\n    get running(): boolean {\n        return this._running;\n    }\n\n    /**\n     * The current rate (relative to real time) the clock runs at.\n     */\n    get rate(): number {\n        return this._rate;\n    }\n\n    /**\n     * The minimum limit for time on the clock.\n     */\n    get minimum(): number {\n        return this._minimum;\n    }\n\n    /**\n     * The maximum limit for time on the clock.\n     */\n    get maximum(): number {\n        return this._maximum;\n    }\n\n    /**\n     * Whether the clock will loop around after reaching the maximum.\n     */\n    get loop(): boolean {\n        return this._loop;\n    }\n\n    // Setters\n    /**\n     * Sets the current clock time.\n     */\n    set time(time: number): void {\n        // Do not allow setting an invalid value\n        if (isNaN(time) || time === -Infinity || time === Infinity) {\n            throw new Error('Can only set time to a finite number');\n        }\n\n        // Only act if the time is different\n        // Note: If time is changing, it is always assumed to be different\n        const currentTime = this.time;\n        if (\n            !(\n                !this._running ||\n                this._rate === 0.0 ||\n                !this._loop && (\n                    this._rate < 0 && currentTime === this._minimum ||\n                    this._rate > 0 && currentTime === this._maximum\n                )\n            ) || time !== currentTime\n        ) {\n            // Recalibrate by setting both correct time and now\n            this._previousTime = Math.min(Math.max(this._minimum, time), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('settime');\n        }\n    }\n\n    /**\n     * Starts or stops running the clock.\n     */\n    set running(running: boolean): void {\n        // Changing running state just calls start() or stop()\n        running ? this.start() : this.stop();\n    }\n\n    /**\n     * Sets the rate (relative to real time) at which the clock runs.\n     */\n    set rate(rate: number): void {\n        // Do not allow setting an invalid value\n        if (isNaN(rate) || rate === -Infinity || rate === Infinity) {\n            throw new Error('Can only set rate to a finite number');\n        }\n\n        // Only act if the rate is different\n        if (rate !== this._rate) {\n            // Recalibration is only needed when we're running\n            if (this._running) {\n                this._previousTime = this.time;\n                this._previousNow = this._now();\n            }\n\n            // Set rate\n            this._rate = rate;\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setrate');\n        }\n    }\n\n    /**\n     * Sets minimum limit for time on the clock.\n     */\n    set minimum(minimum: number): void {\n        // Do not allow setting an invalid value\n        if (minimum > this._maximum || isNaN(minimum) || minimum === Infinity) {\n            throw new Error('Cannot set minimum above maximum');\n        }\n\n        // Only act if the minimum is different\n        if (minimum !== this._minimum) {\n            // First get the calculated time, calculated using the old minimum\n            const previousTime = this.time;\n\n            // Change the minimum\n            this._minimum = minimum;\n\n            // Recalibrate the time using the previous value and the new minimum\n            this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setminimum');\n        }\n    }\n\n    /**\n     * Sets maximum limit for time on the clock.\n     */\n    set maximum(maximum: number): void {\n        // Do not allow setting an invalid value\n        if (maximum < this._minimum || isNaN(maximum) || maximum === -Infinity) {\n            throw new Error('Cannot set maximum below minimum');\n        }\n\n        // Only act if the maximum is different\n        if (maximum !== this._maximum) {\n            // First get the calculated time, calculated using the old maximum\n            const previousTime = this.time;\n\n            // Change the maximum\n            this._maximum = maximum;\n\n            // Recalibrate the time using the previous value and the new maximum\n            this._previousTime = Math.min(Math.max(this._minimum, previousTime), this._maximum);\n            this._previousNow = this._now();\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setmaximum');\n        }\n    }\n\n    /**\n     * Sets whether the clock loops around after reaching the maximum.\n     */\n    set loop(loop: boolean): void {\n        // Only act if looping is different\n        if (loop !== this._loop) {\n            // Recalibrate\n            this._previousTime = this.time;\n            this._previousNow = this._now();\n\n            // Set looping\n            this._loop = loop;\n\n            // Recalculate time listeners\n            this._recalculateTimeListeners();\n\n            // Trigger event listeners\n            this.trigger('setloop');\n        }\n    }\n}\n"]}